# MySQL 아키텍처 (1)

## 학습할 것

- MySQL 엔진 아키텍처
  - 구조와 MySQL엔진, 스토리지 엔진
- MySQL 스레딩 구조
  - 포그라운드 스레드와 백그라운드 스레드
- 메모리 할당 및 사용 구조
  - 글로벌 메모리 영역과 로컬 메모리 영역
- 쿼리 실행 구조

## MySQL 엔진 아키텍처

![image](https://github.com/todolist-team2/todo-max/assets/66981851/e397c989-6fbd-474a-8fa4-b5e466f5e652)

MySQL 서버는 크게 MySQL 엔진과 스토리지 엔진으로 구분할 수 있다.

### 스토리지 엔진

MySQL 엔진은 주어진 SQL을 처리하거나 최적화하는 부분을 담당하고, 스토리지 엔진은 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어들인다.

MySQL 서버에서 MySQL 엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있다. 테이블이 사용할 스토리지 엔진을 지정하면 모든 읽기나 변경작업은 스토리지 엔진이 처리한다.

### 핸들러 API

MySQL 엔진의 쿼리 실행기에서 데이터를 읽거나 쓸 때는 각 스토리지 엔진에 요청을 보내는데 이를 `핸들러 요청`이라 하고, 여기서 사용되는 API를 `핸들러 API`라고 한다.

## MySQL 스레딩 구조

MySQL은 프로세스 기반이 아닌, 스레드 기반으로 동작을 하고, 크게 포그라운드 스레드와 백그라운드 스레드 두 가지로 구분할 수 있다.

> 위의 스레딩 구조는 MySQL 커뮤니티 에디션의 전통적인 스레드 모델이다. MySQL 엔터프라이즈 에디션과 Percona MySQL 서버에서는 스레드 풀 모델을 사용할 수도 있다. <br>
> MySQL의 전통적인 스레드 모델에서는 커넥션 별로 포라운드 스레드가 하씩 생성되고 할당된다. 하지만 스레드 풀에서는 포그라운드 스레드와 커넥션이 1:1 관계가 아니라 하나의 스레드가 여러 개의 커넥션 요청을 전담한다.

### 포그라운드 스레드 (클라이언트 스레드)

포그라운드 스레드는 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재한다. MySQL 서버에서는 클라이언트 커넥션의 요청을 처리하기 위해 스레드가 하나씩 할당된다. 각 스레드는 요청을 처리하고 스레드 캐시에 반납되는데, 이때 스레드 캐시에 일정 개수 이상의 스레드가 대기하고 있다면 스레드 캐시에 넣지 않고 스레드를 종료시켜 스레드 캐시에 일정 개수의 스레드만 존재하게 한다. 이때 스레드 캐시에 존재할 수 있는 최대 스레드의 수는 `thread_cached_size` 시스템 변수로 설정한다.

MySQL 포그라운드 스레드는 데이터를 캐시나 데이터 버퍼에서 읽어오는데, 데이터가 캐시나 데이터 버퍼에 존재하지 않는다면 디스크에서 직접 값을 읽어와 작업을 처리한다.
MyISAM 엔진의 경우 포그라운드 스레드가 디스크 쓰기 작업까지 포그라운드 스레드가 처리하지만 InnoDB의 경우 포그라운드 스레드는 캐시나 데이터 버퍼까지만 처리하고, 나머지 버퍼로부터부터 디스크까지 쓰는 작업은 백그라운드 스레드가 담당한다.

![image](https://github.com/CodeSquad-2023-BE-Study/DB-Study/assets/66981851/53087194-848b-49a0-b2be-db6b3332fe03)

### 백그라운드 스레드

InnoDB는 다음과 같은 작업들이 백그라운드 스레드로 처리된다.

- 인서트 버퍼(Insert Buffer)를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

중요한 것은 로그 스레드(Log thread)와 쓰기 스레드(write thread)이다.

일반적인 상용 RDBMS는 쓰기 작업을 버퍼링해서 일괄적으로 처리하는 기능을 지원하는데, InnoDB또한 이러한 방식으로 처리한다. 일괄적으로 처리하기 떄문에 InnoDB의 경우 UPDATE, DELETE, INSERT 쿼리로 데이터가 변경될 떄까지 기다리지 않아도 된다.

![image](https://github.com/CodeSquad-2023-BE-Study/DB-Study/assets/66981851/49e5d075-89f3-4a45-bd35-121a4f6740b5)

[MySQL 스레딩 모델]

## 메모리 할당 및 사용 구조

MySQL에서 사용되는 메모리 영역은 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있다. 글로벌 메모리 영역과 로컬 메모리 영역은 MySQL의 스레드가 메모리 영역을 공유해서 사용하는 공간인지 여부에 따라서 구분된다.

### 글로벌 메모리 영역

- MySQL이 시작되면서 운영체제에 의해 할당된다.
- 일반적으로 클라이언트 수와 무관하게 하나만 할당한다.
- 필요에 따라 두 개 이상이 할당 받을 수는 있지만, 모든 메모리 영역은 모든 스레드에 의해 공유된다.
- 대표적인 글로벌 메모리 영역
  - 테이블 캐시
  - InnoDB와 버퍼 풀
  - InnoDB 어댑티브 해시 인덱스
  - InnoDB 리두 로그 버퍼

### 로컬 메모리 영역

- MySQL상의 포그라운드 스레드(클라이언트 스레드)가 쿼리를 처리하는데 사용하는 영역
- 포그라운드 스레드 별로 하나씩 할당되며, 절대 공유되지 않는다.
- 각 쿼리의 용도별로 필요할 때만 할당되고 필요하지 않으면 MySQL이 할당조차도 하지 않을 수 있다.
  - 소트 버퍼나 조인 버퍼같은 경우 할당조차 하지 않음.
- 커넥션이 유지되는 동안 할당되는 공간도 있고 쿼리가 실행될 때만 할당되고 다시 해제하는 공간이 있다.
  - 커넥션 -> 커넥션 버퍼, 결과 버퍼
  - 쿼리 -> 소트 버퍼, 조인 버퍼
- 대표적인 로컬 메모리 영역
  - 정렬 버퍼
  - 조인 버퍼
  - 바이너리 로그 캐시
  - 네트워크 버퍼

## 쿼리 실행 구조

![image](https://github.com/CodeSquad-2023-BE-Study/DB-Study/assets/66981851/757b778a-5d77-4089-b323-ed9628b46aaf)

위는 MySQL에서 쿼리를 실행할 때의 구조를 간략하게 표현한 그림이다. 각 기능별로 알아보자.

### 쿼리 파서

- 사용자 요청으로 들어온 쿼리 문장을 토큰(MySQL이 인식할 수 있는 최소 단위의 어휘나 기호)으로 분리해 트리 형태의 구조를 만들어 내는 작업이다.
- 쿼리 문법 오류는 여기서 발견되고 사용자에게 오류메시지를 전달한다.

### 전처리기

- 파서 트리를 기반으로 쿼리 문장에 구조적인 문제가 있는지 확인한다.
- 실제 존재하지 않거나 권한상 사용할 수 없는 토큰은 여기서 걸러진다.

### 옵티마이저

- 사용자의 쿼리를 가장 싼 비용으로 가장 빠르게 처리할지를 결정하는 역할.

### 실행엔진

만들어진 계획대로 핸들러에게 요청하고 핸들러로부터 받은 요청의 결과를 또 다른 핸들러의 입력으로 연결하는 역할을 수행한다.

예를 들어 이해하자. 옵티마이저가 GROUP BY를 처리하기 위해 임시 테이블을 사용하기로 했다고 결정했다.

1. 실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청
2. 다시 실행 엔진은 WHERE절에 일치하는 레코드를 읽어오라고 요청
3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 핸들러에게 요청
4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어오라고 핸들러에게 다시 요청
5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김

### 핸들러(스토리지 엔진)

MySQL서버의 가장 밑단에서 MySQL 실행엔진의 요청에 따라 디스크로부터 데이터를 읽어오고 쓰는 역할을 한다. 핸들러는 결국 스토리지 엔진을 의미한다.

# MySQL 아키텍처 (2) - InnoDB 스토리지 엔진 아키텍처

## 학습할 것

- MVCC
- 잠금 없는 일관된 읽기

## MVCC (Multi Version Concurrency Control)

DB는 Lock을 기본으로 해 데이터 파일에 작성된 데이터들의 일관성을 보장해주지만 이것은 쓰기가 많이 일어나는 서버에서의 동시성을 크게 떨어뜨린다.
이런 문제를 해결하기 위해 나온 것이 MVCC인데, MVCC의 가장 큰 목적은 잠금을 사용하지 않은 일관된 읽기를 제공하는 것이다.

RDBMS에서 구현하는 MVCC는 크게 두 가지로 나눌 수 있다.

1. Pessimetic Lock을 이용하는 방식
2. Undo log를 이용하는 방식

이중 InnoDB는 Undo log를 통해 MVCC를 구현한다.

메모리에 언두 영역을 따로 두고 최신 데이터는 데이터 영역에, 올드 데이터는 언두 영역에 두면서 레코드에 대한 버전을 관리하는 방식이다.

예를 들어 살펴보자.

우선 다음과 같은 테이블에 한 건의 레코드를 INSERT하고 UPDATE해서 발생하는 변경 작업 절차를 확인해보자.

```sql
create table member (
    m_id int not null,
    m_name varchar(20) not null,
    m_area varchar(100) not null,
    primary key (m_id),
    index ix_area (m_area)
);

insert into member (m_id, m_name, m_area) values (12, '홍길동', '서울');
commit;
```

INSERT 문이 실행되면 데이터베이스는 다음과 같은 상태가 된다.
![image](https://github.com/CodeSquad-2023-BE-Study/DB-Study/assets/66981851/00d86946-122c-4f12-a3c7-f51ac4db1be1)

이제 UPDATE 문이 실행될때의 처리 절차를 보자.

```sql
update member set m_area = '경기' where m_id=12;
```

![image](https://github.com/CodeSquad-2023-BE-Study/DB-Study/assets/66981851/cdf110c8-f673-480c-81ac-a472f39da444)

- 언두 로그에는 m_area 열의 변경 전 값만 복사된다.
- UPDATE문장이 실행되면 커밋의 실행여부와 상관없이 InnoDB의 버퍼 풀이 업데이트 된다.
- 디스크의 데이터 파일에는 체크포인트나 Write 스레드에 의해 새로운 값으로 업데이트되어 있을 수도 있고 아닐 수도 있다. (일반적으로는 InnoDB의 버퍼풀과 동일한 상태라 봐도 무방하다.)

이제 COMMIT이나 ROLLBACK 되지 않은 상황에서 레코드를 조회하면 어디에 있는 데이터가 조회될까?

```sql
select * from member where m_id=12;
```

MySQL 서버의 시스템 변수와 설정된 격리 수준에 따라 다르다.

격리 수준이 READ_UNCOMMITED (커밋되지 않은 데이터도 읽어올 수 있다.) 경우 InnoDB 버퍼 풀이 가지고 있는 데이터를 읽어 반환한다.

격리 수준이 READ_COMMITED나 그 이상인 경우 아직 커밋되지 않았기 때문에 언두 영역에 있는 데이터를 반환한다.
이런 과정을 MVCC라고 한다.

## 잠금 없는 일관된 읽기

InnoDB 스토리지 엔진은 위의 MVCC(Multi Version Concurrency Control)를 이용해 잠금 없는 일관된 읽기를 수행할 수 있다.

A라는 사용자가 한 레코드를 수정하고 있는 도중에 B라는 사용자가 해당 레코드를 순수하게 조회하려 할 때 트랜잭션의 변경 작업과 관계없이 언두 로그를 사용해서 잠금을 대기하지 않고 바로 실행할 수 있다.

## InnoDB 버퍼 풀

InnoDB 버퍼 풀은 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다. 버퍼라는 말은 InnoDB가 쓰기 작업을 지연시켜 일괄로 작업을 처리할 수 있게 해주는 버퍼 역할도 하기 때문이다.

### 버퍼 풀의 구조와 LRU 알고리즘

InnoDB 스토리지 엔진은 메모리 공간을 `page`단위로 나누어 관리하며, 한 페이지에 여러 row가 속할 수 있다.
버퍼 풀의 페이지들을 관리하기 위해서 InnoDB는 다음과 같은 자료 구조를 관리한다.

- LRU (Least Recently Used) 리스트
- 프리 (Free) 리스트
- 플러시 (Flush) 리스트

#### LRU 리스트

LRU 리스트는 다음과 같은 구조를 띄고 있다.
![image](https://github.com/CodeSquad-2023-BE-Study/DB-Study/assets/66981851/3a9e8f7a-2333-42aa-8d57-d7d173a1641f)

LRU 리스트를 관리하는 목적은 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB에 유지해 디스크 읽기를 최소화 시키는 것이다.

기본적으로 LRU 알고리즘은 다음과 같은 절차를 따른다.

- 버퍼 풀의 3/8은 Old sublist에 사용된다.
- Midpoint는 Old sublist의 Head와 New sublist의 Tail이 만나는 지점이다.
- InnoDB가 버퍼 풀에 페이지를 넣을 때, midpoint에 삽입하게 된다.
- Old sublist에 있는 페이지에 접근할 경우 그 페이지를 New sublist의 Head로 이동시켜 `young`하게 만든다.
- 데이터 베이스의 작업이 계속되면서 버퍼 풀에 있는 데이터 페이지들 중 사용되지 않는 페이지들은 자연스럽게 전체 리스트의 Tail로 이동하게 된다. Old sublist의 페이지들은 midpoint에 새로운 페이지가 삽입됨에 따라서 Tail과 가까워지고, 결국 버퍼 풀에서 삭제 된다.

[참고 - MySQL LRU](https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html)

#### 프리 리스트

프리 리스트는 InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은, 비어 있는 페이지들의 목록이며 사용자의 쿼리가 새롭게 디스크의 페이지를 읽어와야 하는 경우 사용된다.

#### 플러시 리스트

플러시 리스트는 디스크로 동기화 되지 않은, 데이터 변경이 가해진 페이지(더티 페이지)의 목록을 관리한다.

## 어댑티브 해시 인덱스

보통 `인덱스`라 하면 `B-Tree` 인덱스를 생각하게 된다. 데이터는 PK 순으로 정렬되어 있다.

`B-Tree` 인덱스에서 특정 데이터를 찾기 위해서는 루트에서 리프노드까지 탐색을 진행해야 합니다. 트리의 특징 때문에 데이터 접근 성능이 데이터의 양에 따라 선형적으로 증가하지 않는다는 특징이 있습니다.

InnoDB Adaptive Hash Index는 B-Tree의 한계를 보완할 수 있는 좋은 기능입니다.

특히 단일 랜덤 키 접근이 빈도있게 발생하는 경우라면, B-Tree 를 통하지 않고 데이터에 접근/처리가 가능하기에 좋은 퍼포먼스를 보입니다.

그러나, 자주 사용되는 데이터를 옵티마이저가 판단하여 해시 키로 만들기 때문에 제어가 어려우며, 수 개월 동안 사용되지 않던 테이블일지라도 기존 해시 자료 구조에 데이터가 남아 있게 되면, 테이블 Drop 시 영향을 줄 수 있습니다. 해시 인덱스에 의존하여 트래픽이 주로 처리되는 서비스인 경우 이런 점을 염두해 두고 사용을 해야겠습니다.


## 참고 자료

[Real MySQL 8.0 1권](http://www.yes24.com/Product/Goods/103415627)
